#### js运行机制详解
```
https://juejin.im/post/5e22b391f265da3e204d8c14

浏览器进程：
	1. Browser进程(浏览器主进程)
	2. 第三方插件进程(一个插件对应一个进程)
	3. GUI进程(用于3D绘制等)
	4. 渲染进程(重)
		4.1 即通常所说的浏览器内核(Renderer进程，内部是多线程)
		4.2 每个Tab页面都有一个渲染进程，互不影响
		4.3 主要作用为页面渲染，脚本执行，事件处理等
		
渲染进程(Renderer)的主要线程
	1. GUI渲染线程
		作用：负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等
		
	2. JS引擎线程
		作用：JS引擎线程就是JS内核，负责处理Javascript脚本程序(例如V8引擎)
		浏览器同时只能有一个JS引擎线程在运行JS程序，所以js是单线程运行的
	
	3. 事件触发线程
		属于浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列(task queue)
		当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，
		等待JS引擎的处理(比如定时器计时完毕添加到事件队列末尾，比如http请求响应后再把回调函数添加到事件队列末尾)
	
	4. 定时触发线程
		setInterval与setTimeout所在线程
	
	5. 异步http请求线程
		在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
	
事件循环(Event Loop)
	JS分为同步任务和异步任务, 普通代码为同步任务，定时器和异步http请求为异步任务
	
	JS引擎执行执行栈 
	---> 执行同步任务(通知定时器线程和异步任务线程在触发回调时将回调插入任务队列末尾) 
	---> 执行栈中同步任务执行完毕 
	---> 检查任务队列中是否有事件回调(只要可执行栈是空的，就一直检查任务队列中是否有事件回调)
	---> 继续执行事件回调
	
	小结：JS引擎先执行 "执行栈"中 的同步代码，遇到"setTimeout"和"setInterval"就移交给 "定时器线程"，遇到"http请求"就移交给 "异步http请求线程"，
		等到 "执行栈" 为空，就一直向 "事件触发线程" 发起询问，如果 "事件队列" 中有回调函数，就执行回调，就这样反反复复。
		
宏任务(macrotask)和 微任务(microtask)
	浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务
	微任务和宏任务不在一个任务队列，不在一个任务队列
	
	注意：
		无微任务的情况：
			宏任务 -> GUI渲染 -> 宏任务 -> ...
		有微任务的情况：
			宏任务 -> 微任务 -> GUI渲染 -> 宏任务 -> ...
		
		在有微任务情况下，如果宏任务中触发的dom布局和样式改变，在微任务中又改变了，就会直接渲染微任务中的
		
		例如:
		document.body.style = 'background:blue';
		setTimeout(()=>{
			document.body.style = 'background:black'
		},200)
		无微任务的时候，背景颜色会先蓝后黑
		
		document.body.style = 'background:blue'
		Promise.resolve().then(()=>{
			document.body.style = 'background:pink'
		});
		有微任务的时候，背景颜色直接渲染成粉红，并不会渲染为蓝色

		
	
一些思考的问题：
	1. 为什么浏览器要多进程？
		(多进程优势)假设浏览器是单进程，某个插件，某个tab页崩溃了，就会导致整个浏览器崩溃，非常影响用户体验。
		(多进程劣势)浏览器进程很多，每个进程又有很多线程，都会占用内存，内存资源消耗会很大，有点拿空间换时间的意思。
		所以浏览器开多了，时间开久了，电脑就会卡，内存资源消耗巨大
		
	2. 浏览器页加载慢，出现卡顿是什么情况？
		原因：GUI渲染线程与JS引擎线程是互斥的
		当JS引擎执行时，GUI线程会被挂起，停止页面的布局和绘制，
		如果JS执行时间过长，就会导致页面渲染不连贯，导致页面渲染加载阻塞的情况。(让用户觉得加载慢，页面卡顿)
		
	3. Promise内的任务属于同步任务还是异步任务？Promise,Promise.then,setTimeout 任务的执行顺序？
		
		例1：(Promise)
        console.log('任务1'); // 1

        setTimeout(() => {
            console.log('任务2'); // 5
        })

        new Promise((resolve) => {
            console.log('任务3') // 2
            resolve()
        }).then(()=>{
            console.log('任务4') // 4
        })

        console.log('任务5') // 3
		
		执行顺序：
			任务1(同步任务) => 任务3(同步任务) => 任务5(同步任务) => 任务4(微任务) => 任务5(宏任务)
		
		结论：
			在Promise的构造函数中的任务是同步任务，在Promise.then()函数中的任务是异步微任务，在setTimeout中的任务是异步宏任务
		
		
	
		例2：(async / await)
        console.log('任务1'); // 1

        setTimeout(() => {
            console.log('任务2'); // 5
        })

        async function test() {
            console.log('任务3')
            await Promise.resolve()
            console.log('任务4')
        }

        console.log('任务5') // 3
		
		执行顺序：
			任务1(同步任务) => 任务3(同步任务) => 任务5(同步任务) => 任务4(微任务) => 任务5(宏任务)
			
		结论：
			在async中，await之前的代码相当于Promise的同步任务，await之后的代码相当于Promise.then的异步



```
